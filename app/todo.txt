
只能用最少的时间脱贫，才能用最多的时间致富
每花一分钟时间在营生，就少花一分钟经营事业
财务自由是当下社会做你人生意愿的必备条件

3-17
---------------
1.完成了更新事件状态的操作 √

    问题①：
        通过在ViewHolder bind()中去设置点击事件 回传position会出现数据错乱,响应有问题
        分析:
            拿新增一个Event来说，因为内部类的问题，position在创建点击事件的时候可能就一直都固定了
        解决:
            DataBinding中绑定了Event,将eventId回传到ViewModel,再通过id去修改，id唯一所以一定不回出错

2.使用BindingAdapter完成根据状态显示相符合的图片 √

    好处: 减少了Adapter中大量的判断，xml化

3.一些新奇的发现

    使用Room插入数据后发现没有往ViewModel中的List去添加数据，数据依旧会更新，并且更新Item的字段也会达到这个效果
具体的原因没有去查，但是相对还是非常有意思的。
3-18 计划
-------------
1.完成Section可能因为排序而导致有多条相同Section
    这个问题主要原因可能是数据源获取时OrderBy 和 GroupBy的数据库语句造成的
    尝试:
        完成一个Event确实完成了刷新，但是当前List中的排序还是原来的规则，所以会导致出现多个重复的Section，submitList
    的List考虑重新去执行一次查询的话，效率上肯定大打折扣，去写一个自己的排序规则的话，感觉也有问题。
2.时间选择器 重要事件切换 (软键盘中的那些操作)
3-18
------------
1.完成重要事件的创建
    1.1 send按钮的图片状态取决于输入内容的为空与否 √
    1.2 send发送，添加成功后布局状态结束，否则点击添加后保存上一次的输入内容 √
    1.3 重要事件与否的状态记录和直接通过dataBinding自己关注，不再需要通过代码去完成订阅 √

        dataBinding 思考：
        Demo中对同一个属性，对viewModel自己而言通过MutableLiveData来做封装，对暴露给给外部使用的通过LiveData来封装
        达到一种效果：对内可变，对外不可变，外部拿到的始终是一个对它而言很安全的数据，而且似乎dataBinding做了对LiveData
        的适配，我没有传入LiveData，它自行进行了取值value的操作

    想要用ViewModel来存储这些状态，发现键盘布局是通过include进来的，会出现aDataBinding.bDataBinding的恶心代码。如果
    不使用include界面又会显得太复杂，切复用性会收到限制(最后思考，不同风格的键盘布局是不一样的，所以规避复用性问题)
2.完成重要事件的时间选择问题
    2.1 上来materialDatePicker就出现了问题
        反而找到了一些关于搭建一个material风格App的指引(ps:周末可以好好看看，构建一个好看的OneDay)
        https://codelabs.developers.google.com/codelabs/mdc-android/index.html?index=..%2F..index#0
    2.2 找到了一篇指引文章
        https://ahsensaeed.com/android-material-design-library-date-picker-dialog/
    2.3 关于MD(这块要下点儿功夫 感觉问题挺多的 特别是颜色这块)
        https://material.io
3-19 计划 研究好MD 开发出MD友好的界面交互来
----------
    1.研究好Theme
    2.可以把图标切换为Google官方的图标 在Material.io中
    3.完成时间的选择
    MD风格配色预览：　ColorTool
        https://material.io/resources/color
3-19
----------
    1.找到了新大陆 animated vector drawable 让图标动画起来 ★★★★★
    https://sourcediving.com/android-recipes-the-easy-path-to-animated-icons-878bffcb0920
    AnimatedVectorDrawableCompat
    要有一个好的体验：AnimatedVectorDrawableCompat 能够支持我们从一个svg友好的过渡到另一个svg，但是要逆向的话，需要
    编写代码，可以通过自定义View来完善这一件事情,但是最大的问题在于AnimatedVectorDrawableCompat需要两个兼容的SVG
        (仅当两个SVG图像的路径具有相同的命令，相同的顺序并且每个命令具有相同数量的参数时，它们才适用于变形变换。)
        这就是最大的问题所在，因为设计师不会考虑将两个不同的图标关联出相同的Path来，这对设计师来讲没有意义，如果让我们自己
    手动去修改Path直到它们兼容，这样是很难的，很费时间
    step1: 两张相同大小的svg
    step2: https://shapeshifter.design/
           对两张SVG做过渡动画
    step3: 做出反向动画
    step4: 自定义View来切换两种状态
    制作教程视频:https://www.youtube.com/watch?v=v7I6eo4Fo6U

    晚上回去做图标和体验，白天来完善代码逻辑比较合适

    md 好文章 ★★★★★ (对MD有了全新更深的理解和运用)
    https://medium.com/over-engineering/setting-up-a-material-components-theme-for-android-fbf7774da739
    多模式切换
    https://segmentfault.com/a/1190000021907887

    问题：colorSurface 始终会变亮一点 有点搞不懂 ~