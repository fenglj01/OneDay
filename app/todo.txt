
只能用最少的时间脱贫，才能用最多的时间致富
每花一分钟时间在营生，就少花一分钟经营事业
财务自由是当下社会做你人生意愿的必备条件

3-17
---------------
1.完成了更新事件状态的操作 √

    问题①：
        通过在ViewHolder bind()中去设置点击事件 回传position会出现数据错乱,响应有问题
        分析:
            拿新增一个Event来说，因为内部类的问题，position在创建点击事件的时候可能就一直都固定了
        解决:
            DataBinding中绑定了Event,将eventId回传到ViewModel,再通过id去修改，id唯一所以一定不回出错

2.使用BindingAdapter完成根据状态显示相符合的图片 √

    好处: 减少了Adapter中大量的判断，xml化

3.一些新奇的发现

    使用Room插入数据后发现没有往ViewModel中的List去添加数据，数据依旧会更新，并且更新Item的字段也会达到这个效果
具体的原因没有去查，但是相对还是非常有意思的。
3-18 计划
-------------
1.完成Section可能因为排序而导致有多条相同Section
    这个问题主要原因可能是数据源获取时OrderBy 和 GroupBy的数据库语句造成的
    尝试:
        完成一个Event确实完成了刷新，但是当前List中的排序还是原来的规则，所以会导致出现多个重复的Section，submitList
    的List考虑重新去执行一次查询的话，效率上肯定大打折扣，去写一个自己的排序规则的话，感觉也有问题。
2.时间选择器 重要事件切换 (软键盘中的那些操作)
3-18
------------
1.完成重要事件的创建
    1.1 send按钮的图片状态取决于输入内容的为空与否 √
    1.2 send发送，添加成功后布局状态结束，否则点击添加后保存上一次的输入内容 √
    1.3 重要事件与否的状态记录和直接通过dataBinding自己关注，不再需要通过代码去完成订阅 √

        dataBinding 思考：
        Demo中对同一个属性，对viewModel自己而言通过MutableLiveData来做封装，对暴露给给外部使用的通过LiveData来封装
        达到一种效果：对内可变，对外不可变，外部拿到的始终是一个对它而言很安全的数据，而且似乎dataBinding做了对LiveData
        的适配，我没有传入LiveData，它自行进行了取值value的操作

    想要用ViewModel来存储这些状态，发现键盘布局是通过include进来的，会出现aDataBinding.bDataBinding的恶心代码。如果
    不使用include界面又会显得太复杂，切复用性会收到限制(最后思考，不同风格的键盘布局是不一样的，所以规避复用性问题)
